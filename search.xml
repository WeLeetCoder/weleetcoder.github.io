<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js学习链接</title>
      <link href="/2019/04/07/js-learn/"/>
      <url>/2019/04/07/js-learn/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Apr 07 2019 22:27:15 GMT+0800 (China Standard Time) --><p><a href="https://segmentfault.com/a/1190000012806637" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012806637</a></p><p><a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007535316</a></p><p>/ - [] github</p><p>/ - [x] github</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo 踩坑记</title>
      <link href="/2019/04/06/hexo-cai-guo-de-keng/"/>
      <url>/2019/04/06/hexo-cai-guo-de-keng/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Apr 07 2019 22:27:15 GMT+0800 (China Standard Time) --><h3 id="文章标签、分类怎么分"><a href="#文章标签、分类怎么分" class="headerlink" title="文章标签、分类怎么分"></a>文章标签、分类怎么分</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> hexo 详解<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> ok<span class="token punctuation">,</span> <span class="token punctuation">-</span> right<span class="token key atrule">categories</span><span class="token punctuation">:</span> <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2019-04-06 18:17:09</span><span class="token punctuation">---</span></code></pre><p>这个是用的 <code>yaml</code> 语法，缩进要一致，冒号（<code>:</code>）之后要一空格，否则可能会报错。</p><h2 id="发布错误"><a href="#发布错误" class="headerlink" title="发布错误"></a>发布错误</h2><p>出现了个很神奇的问题，使用下面的命令，发布 blog 的时候：</p><pre><code>$ hexo d</code></pre><p>我的blog，出现了神奇的 <code>404</code> ，哦豁，凉了，上github上一看，发现，提交了什么鬼啊，把源文件提交上来了</p><p><img src="https://raw.githubusercontent.com/2640710087/pic/master/img/20190407221550.png" alt="上传错误"></p><p>这就不爽了啊，怎么办啊，找了半天，差点吧git都删除了，最后重启，提交，成功…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这坑踩的，真的是冤死啊，莫名其妙的，不定期更新本文。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 hexo 在github上搭建个人博客</title>
      <link href="/2019/04/06/hexo-using/"/>
      <url>/2019/04/06/hexo-using/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Apr 07 2019 22:27:15 GMT+0800 (China Standard Time) --><h2 id="hexo-搭建个人博客"><a href="#hexo-搭建个人博客" class="headerlink" title="hexo 搭建个人博客"></a>hexo 搭建个人博客</h2><p>​ 这两天，突然想搭建一个博客记录一些东西会比较好，但是，自己写的话，时间成本太高，并且，没有啥动力，就想起了之前看过有关 hexo 的文章，就想试试，谁知道，一搭建就是差不多一整天，加上找主题，修改主题，花了差不多一天时间，博客终于上线了；下面，我分享一些如何使用 hexo 搭建属于自己的博客，并且将它部署到 github 上去，部署到 github 上就可以随时随地看博客啦，还能发给朋友看，最爽的是不用花钱就能部署一个博客，多好啊。搭建博客的过程中，我遇到了很多坑，以至于花了我将近一天的时间，时间宝贵啊，下面我分享下搭建的心得吧！</p><p>​ hexo 是一款简洁高效的博客框架，使用它你能够快速搭建起一个博客网站，可以从<a href="https://hexo.io/zh-cn" target="_blank" rel="noopener">hexo官网</a>找到使用的教程。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>在分享之前，首先要确定您的系统环境，以及一些必要的工具是否安装好了，下面两个工具是必须的：</p><ol><li>Git 是用来上传文件到 github 上去的，没有的话可以从 <a href="https://git-scm.com/" target="_blank" rel="noopener">git 的官网</a>下载。</li><li>node，这个是主要的，因为 hexo 框架是基于 node 搭建的，可以从 <a href="https://nodejs.org/en" target="_blank" rel="noopener">node官网</a> 下载。</li></ol><p>安装完成之后，可以用以下命令检测以下：</p><pre><code>$ git --versiongit version 2.20.1.windows.1$ node --versionv8.11.3</code></pre><p>如果能够显示出对应的版本号，就代表安装成功了。</p><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><p>既然环境已经配置好了，没有啥问题了，那就进入正题吧，安装 hexo，用以下的命令安装：</p><pre><code>$ npm install hexo-cli -g</code></pre><p>npm 是 node 自带的node 包管理工具，只要安装了 node 就会附带，<code>-g</code> 参数是全局安装，也就是说安装完成之后，无论在哪个目录下，都能够使用 <code>hexo</code> 命令了。</p><pre><code>$ hexo versionhexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64http_parser: 2.8.0node: 8.11.3v8: 6.2.414.54uv: 1.19.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.32.0napi: 3openssl: 1.0.2oicu: 60.1unicode: 10.0cldr: 32.0tz: 2017c</code></pre><p>使用 <code>hexo version</code> 看看 hexo 是否安装成功。</p><p>安装成功之后，接下来就是创建一个博客了，选定一个目录，在这个目录下执行：</p><pre><code>$ hexo init blog # blog 是文件夹名字，不一定要叫这个名字</code></pre><p>如果命令执行成功的话，会在当前目录下创建一个名字叫 <code>blog</code> 的目录，</p><pre><code>$ cd blog       # 进入 blog 的目录$ dir _config.yml     # 配置文件node_modules    package.json  scaffolds       # 博客的模板source          # 写博客的地方themes          # 存放博客的主题的地方yarn.lock     </code></pre><p>接下来使用：</p><pre><code>$ hexo serverINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>就能够启动一个服务器了，现在打开浏览器，输入<code>http://localhost:4000</code> ，就能够看到你的博客网站了。</p><p><img src="https://i.loli.net/2019/04/06/5ca8531e63c76.png" alt="hexo 默认的主题"></p><p>这是默认的主题，我们可以从<a href="https://hexo.io/themes" target="_blank" rel="noopener">hexo 官网</a>找到好看的主题，然后替换。</p><h5 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h5><pre><code>...title: Hexo                # 这是网站的标题subtitle:                   # 这是网站的副标题 description:               # 网站的描述keywords:                  # 网站 SEO 的关键字author: John Doe           # 网站的作者language:                  # 语言timezone:                  # 时区...</code></pre><p>配置文件还有太多能配置的了，就不一一赘述了，切换主题主要是修改根目录下的 <strong>_config.yml</strong> 这个配置文件，有的主题，直接修改主题下的配置文件也能够生效，修改根目录的主题就是全局的，下面来换一个主题。</p><p>​ 先找到一个喜欢的主题，然后使用将他下载下来放到 <code>.../blog/themes</code> 目录下，如果是压缩包，需要解压成文件夹（其实每个主题都有对应的安装说明的）。下面以 <code>next</code> 主题为例：</p><pre><code>$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>用 git 从github 上将主题克隆到本地的 <code>themes/next</code> ，命令执行完成之后会在 <code>themes</code> 目录下看到 <code>next</code> 目录，这个目录下就是 <code>next</code> 主题的文件了。</p><blockquote><p>注： 其实每个主题都会有安装的说明，到这其实就可以按照主题的安装说明来配置了，不过有些相同的步骤，还是介绍一下吧！</p></blockquote><p>​ 主题下载好了之后，我们用文本编辑器打开 <code>blog</code> 目录下的 <code>_config.yml</code> 文件；</p><p>修改：</p><pre><code>theme: landscape # 默认主题是  landscape</code></pre><p>为：</p><pre><code>theme： next     # 记得冒号之后有一个空格，没有空格可能会报错。</code></pre><p>修改完成之后，可以启动服务器，看看效果：</p><pre><code>$ hexo server</code></pre><p>服务器启动后，就能够看到你喜欢的主题啦，但是，此时还只不过是开始而已。</p><h3 id="配置-分类、标签、关于页"><a href="#配置-分类、标签、关于页" class="headerlink" title="配置 分类、标签、关于页"></a>配置 分类、标签、关于页</h3><p>一般主题都会提供 <code>标签</code> 、<code>分类</code>、<code>关于</code> 这三个页面的，下面我们来看看如何配置吧：</p><p>首先配置分类：</p><pre><code>$ hexo new page categories</code></pre><p>命令执行完毕，会在 <code>source</code> 目录下创建 <code>categories</code> 目录，这个目录下有 <code>index.md</code> 文件。</p><p>这个文件就是分类的页面了，不过还要配置一下才能使用。</p><p>将文件中的内容改为：</p><pre><code>---title: categories                 # 显示的标题date: 2019-04-06 01:38:38         # 文件创建的日期type: &quot;categories&quot;                # 类型layout: &quot;categories&quot;              # 最重要的就是这个 layout 了---</code></pre><p>然后再在主题的目录下（<code>blog/themes/next</code>），修改配置文件（<code>_conifg.yml</code>） 其中的：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">home</span><span class="token punctuation">:</span> / <span class="token punctuation">|</span><span class="token punctuation">|</span> home  <span class="token comment" spellcheck="true">#about: /about/ || user</span>  <span class="token comment" spellcheck="true">#tags: /tags/ || tags</span>  <span class="token comment" spellcheck="true">#categories: /categories/ || th</span>  <span class="token key atrule">archives</span><span class="token punctuation">:</span> /archives/ <span class="token punctuation">|</span><span class="token punctuation">|</span> archive  <span class="token comment" spellcheck="true">#schedule: /schedule/ || calendar</span>  <span class="token comment" spellcheck="true">#sitemap: /sitemap.xml || sitemap</span>  <span class="token comment" spellcheck="true">#commonweal: /404/ || heartbeat</span></code></pre><p>前面带 <code>#</code> 号的代表被注释了，不会生效；只需要将 <code>#</code> 号删除，然后重启服务器，就能够看到效果啦，像 <code>tags</code> 、<code>about</code> 这些，都是一样的步骤，重复上面的步骤即可。</p><p>配置好了这些以后，就可以愉快的写文章了，写文章可以使用（默认是用<code>scaffolds</code> 下的 <code>post.md</code> 来生成模板）：</p><pre><code>$ hexo new &lt;文章标题&gt;</code></pre><p>运行上面的命令之后，会在 <code>source/_posts</code>目录下生成相应的文件，编辑这个文件即可，有一些参数，可以从 hexo 的官网去看，像一些基础的：</p><pre><code>---title: 测试hexodate: 2019-04-05 16:22:39tags: [hexo,测试]categories: [技术学习，生活分享]---</code></pre><p>需要配置在文章的最上方，会被解析，更多详细参数可以看对应主题的说明，也可以看官网的说明，有一些参数是通用的，想 <code>title、date、tags、categories</code>这些，是通用的，几乎每个主题都有这个几个选项。</p><blockquote><p>配置到这，就差不多能够在您本地愉快的写文章啦，但是本地写的文章，又不能给别人看，多没意思，我们可以将它发布到<code>github</code>上去。</p></blockquote><h3 id="发布到-github"><a href="#发布到-github" class="headerlink" title="发布到 github"></a>发布到 github</h3><p>首先，需要一个 github 账号，这就不用介绍了吧，没有的话可以<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">注册</a>一个。</p><p>注册完成之后，就登录吧！</p><p><img src="https://i.loli.net/2019/04/06/5ca8531bf41f9.png" alt="新创建的 github"></p><p>登录之后，就是这样子的了，什么也没有。</p><p>首先，我们先创建一个仓库吧，点击 <code>Create a repository</code> 创建一个仓库。仓库的名字就是你的用户名为为前置，像这样，我这个账号叫做 <code>bloglearn</code> ，那么仓库名字就叫做 <code>bloglearn.github.io</code>，当然，也可以不叫这个名字，如果仓库的名字叫做<code>blog</code> 就需要通过 <code>https://bloglearn.github.io/blog</code> 来访问，这个又长又臭，所以，我们创建的仓库名就叫做 <code>bloglearn.github.io</code> ，也就是您的<code>用户名</code>加上<code>.github.io</code> 作为仓库的名字，我们就能够通过 <code>https://&lt;您的用户名&gt;.github.io</code> 直接访问博客了。</p><p><img src="https://i.loli.net/2019/04/06/5ca85319255b9.png" alt="创建仓库"></p><p>创建好之后：</p><p><img src="https://i.loli.net/2019/04/06/5ca8548068ab2.png" alt="创建仓库完成"></p><p>它会有一个指示，教您怎么做，可以将您的本地的仓库上传到 github 上。</p><p>首先，我们在本地的博客目录（<code>…/blog</code>），也就是上面创建的 <code>blog</code> 目录下，执行：</p><pre><code>$ git init</code></pre><p>这个命令是将 blog 这个目录初始化为一个仓库。</p><p>到这一步，就差不多了。</p><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><p>可以从<a href="https://hexo.io/zh-cn/docs/deployment" target="_blank" rel="noopener">hexo官网</a>看到如何发布。</p><p>在 <code>blog</code> 目录下执行：</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><p>安装 <code>hexo-deployer-git</code> 插件。</p><p>然后修改根目录下的配置文件（<code>blog/_config.yml</code> ），修改为如下：</p><pre><code>deploy:  type: git  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch] #published  message: [message]</code></pre><blockquote><p>注意：分支必须部署到 <code>master</code> 分支上，否则无法通过 <code>username</code>.github.io 访问。</p></blockquote><table><thead><tr><th><code>repo</code></th><th>库（Repository）地址</th></tr></thead><tbody><tr><td><code>branch</code></td><td>分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td></tr><tr><td><code>message</code></td><td>自定义提交信息 (默认为 <code>Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}</code>)</td></tr></tbody></table><p>如果没有的话，就增加上去吧，如果有的话就修改吧，如果有两个的话，会报错的。</p><p>首先是这样配置的：</p><pre><code>deploy:  type: git   repo: https://github.com/bloglearn/bloglearn.github.io.git  branch: master</code></pre><p>记得，deploy 下面的每行都必须<code>缩进</code>，不然会报错，使用https是需要输入密码来验证的，没有登录过的话，可能无法登录。</p><h4 id="生成-SSH-密钥对"><a href="#生成-SSH-密钥对" class="headerlink" title="生成 SSH 密钥对"></a>生成 SSH 密钥对</h4><pre><code>$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;  # -C 是加上注释文字</code></pre><p>然后将公钥，也就是在<code>%USERPROFILE%/.ssh</code> （<code>%USERPROFILE%</code> 是系统环境变量）目录下，有刚刚创建的文件，以<code>.pub</code> 为后缀的，就是公钥了，将公钥问价打开，复制公钥，一会再在 github 上粘贴。</p><h4 id="创建-Deploy-keys"><a href="#创建-Deploy-keys" class="headerlink" title="创建 Deploy keys"></a>创建 Deploy keys</h4><h4 id="1-打开-blog-存放的仓库"><a href="#1-打开-blog-存放的仓库" class="headerlink" title="1. 打开 blog 存放的仓库"></a>1. 打开 blog 存放的仓库</h4><p><img src="https://i.loli.net/2019/04/06/5ca85319ad95c.png" alt="创建步骤"></p><h4 id="2-先输入一个标题，用于区分公钥串，再将刚刚复制的公钥串粘贴上去。"><a href="#2-先输入一个标题，用于区分公钥串，再将刚刚复制的公钥串粘贴上去。" class="headerlink" title="2. 先输入一个标题，用于区分公钥串，再将刚刚复制的公钥串粘贴上去。"></a>2. 先输入一个标题，用于区分公钥串，再将刚刚复制的公钥串粘贴上去。</h4><p><img src="https://i.loli.net/2019/04/06/5ca854afd2485.png" alt="填写 deploy keys"></p><h4 id="3-添加完成"><a href="#3-添加完成" class="headerlink" title="3. 添加完成"></a>3. 添加完成</h4><p><img src="https://i.loli.net/2019/04/06/5ca854d5726f4.png" alt="添加完成"></p><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h4><pre><code>$ ssh -T git@github.com Hi bloglearn/bloglearn.github.io! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><p>如果这个测试显示的是成功认证，那么就是成功的，反之则失败了，就得找找问题了。</p><h5 id="如果有多个密钥串怎么办？"><a href="#如果有多个密钥串怎么办？" class="headerlink" title="如果有多个密钥串怎么办？"></a>如果有多个密钥串怎么办？</h5><p>可以指定使用某个密钥串来连接的。</p><pre><code>$ ssh -i &lt;指定密钥串的路径&gt; -T git@github.com $ ssh -i %userprofile%/config/.ssh/id_github -T git@github.com      # 我的私钥文件是id_githubPTY allocation request failed on channel 0Hi bloglearn/bloglearn.github.io! You&#39;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.</code></pre><h3 id="上传-blog-到-github-上"><a href="#上传-blog-到-github-上" class="headerlink" title="上传 blog 到 github 上"></a>上传 blog 到 github 上</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>如果有多个 <strong>SSH</strong>密钥的话，可以通过在<code>.ssh</code> 目录下新建一个 <code>config</code> 文件，来管理不同的密钥。</p><h5 id="config-文件内容："><a href="#config-文件内容：" class="headerlink" title="config 文件内容："></a>config 文件内容：</h5><pre class=" language-config"><code class="language-config">Host blog                                            # 这个是一会要用的HostName github.com                                  # 这个是主机名，也就是 git@github.com 的后面部分User git                                             # 用户名，也就是 gitIdentityFile ~/.ssh/id_github                        # 然后就是对应的 私钥文件路径了Host dev                                             HostName github.com                                  User git                                             IdentityFile ~/.ssh/id_dev                       </code></pre><p>当有多个的时候，就像上面那样写就可以了</p><p>然后修改配置文件（<code>_config.yml</code>），修改如下（<code>注意缩进</code>）：</p><pre><code>deploy:  type: git   # 方法1：  repo: git@github.com:bloglearn/bloglearn.github.io.git  # 方法2：  repo: blog:bloglearn/bloglearn.github.io.git   branch: master</code></pre><blockquote><p>可以看到，repo 从原来的 https 改为了 <code>git@github.com:bloglearn/bloglearn.github.io.git</code>，但是由于我配置了多个密钥，因此使用<code>方法2</code>，<code>方法2</code>由<code>方法1</code>的 <a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:<github 用户名>/&lt;仓库名&gt;.git<code>修改为了</code>blog:bloglearn/bloglearn.github.io.git <code>这里前面的</code>blog<code>就是</code>.ssh/config<code>文件内的</code>Host<code>字段，然后后面的一样，只是用</code>Host<code>替换了</code><a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>` ，没有配置多个 <strong>SSH</strong> 密钥的话，直接用 github 给的链接就好啦。</github></p></blockquote><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><p>一切都准备好了，那就开始上传吧！切换回到 blog 目录下，执行下面的命令：</p><pre><code>$ hexo clean </code></pre><p>清空掉之前生成的文件，像<code>public，db.json</code> 这些文件和目录。然后使用：</p><pre><code>$ hexo g           # 等同于 hexo generate</code></pre><pre><code>$ hexo d           # 等同于 hexo deploy</code></pre><p>其实，可以使用 <code>hexo d</code> 即可完成 <code>hexo g</code> 的工作了，在发布的时候记得一定要清空之前的文件。</p><p>等一小会，就上传完成了，如果网速慢的话，那就多等会。</p><h4 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h4><p>如果上面的步骤都没有问题的话，那就已经完成啦！可以打开 &lt;<code>you_username</code>&gt;<code>.github.io</code>， 像我的就是：<a href="https://bloglearn.github.io/" target="_blank" rel="noopener">https://bloglearn.github.io/</a></p><blockquote><p>写作的话是在 <code>source</code> 目录下的 <code>_posts</code> 目录下。当然，也可以使用命令：<code>hexo new &lt;文件名&gt;</code> ，它会根据模板为您在<code>blog/source/_posts</code> 目录下生成相应的文件，您可以修改其内的参数。</p></blockquote><p>有关写作的一些参数可以看看这里 <a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/front-matter</a></p><h4 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h4><p>使用：</p><pre><code>$ hexo new draft &lt;filename&gt; </code></pre><p>会在 <code>source</code> 目录下创建<code>_drafts</code> 目录，这个目录是用来打草稿的，其内的文章在发布的时候不会显示在页面上。</p><p>当执行：</p><pre><code>$ hexo publish &lt;filename&gt;       # filename 不需要加后缀</code></pre><p>它会将对于的文章移动到<code>source/_posts</code> 目录下，进行发布。</p><h4 id="图床使用"><a href="#图床使用" class="headerlink" title="图床使用"></a>图床使用</h4><p>可以使用<a href="https://picgo.github.io/PicGo-Doc/zh/guide/#%E5%BA%94%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">PicGo</a>，很好用，对于写博客来说是必备工具啊。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​ 总体来说，搭建博客也不难，主要是没啥经验，一路磕磕碰碰的，到最后博客上线了之后，是真的很舒服啊，一开始图片是个大问题，hexo 存储图片，路径不太好，用 <code>markdown</code> 原生语法<code>![]()</code>，是真的没办法用，用别的方法吧，在编辑器上看不了图片，难受，所以最后选择了外链，用微博的图床，就很舒服，关键是还免费。其他的问题倒是没有太多。博客还能开通评论，目前没有想要开通的想法，想开通的小伙伴可以看看以下的文章。</p><p><a href="https://www.cnblogs.com/roronoa-sqd/p/5510711.html" target="_blank" rel="noopener">https://www.cnblogs.com/roronoa-sqd/p/5510711.html</a></p><p>百度<a href="https://www.baidu.com" target="_blank" rel="noopener">^链接</a></p><p><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">相关的命令</a></p><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a></p><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><p><a href="https://www.ktanx.com/blog/p/4016" target="_blank" rel="noopener">ssh命令指定密钥连接远程主机</a></p><p><a href="https://www.cnblogs.com/logchen/p/10543808.html" target="_blank" rel="noopener">多个密钥管理多个github/gitlab</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 使用 vendor 包管理工具</title>
      <link href="/2019/04/06/go-vendor/"/>
      <url>/2019/04/06/go-vendor/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Apr 07 2019 22:27:15 GMT+0800 (China Standard Time) --><h3 id="vendor-目录介绍"><a href="#vendor-目录介绍" class="headerlink" title="vendor 目录介绍"></a>vendor 目录介绍</h3><p>Go 从 1.5 release 版本之后，vendor 目录也被添加到了 Go 的依赖目录查找中了，Go 1.6 之前，需要手动设置环境变量<code>GO15VENDOREXPERIMENT=1</code> ，Go 才能够查找 <code>vendor</code> 目录。Go 从 1.6 以后就不需要设置了（在 Go 中无论如何，都需要配置 GOPATH和GOROOT）。</p><p>查找顺序如下所示：</p><ol><li>当前目录下的 vendor 目录</li><li>依次向上一级一级查找 vendor 目录</li><li>然后是 GOROOT</li><li>最后才是 GOPATH</li></ol><h4 id="为什么需要使用-vendor？"><a href="#为什么需要使用-vendor？" class="headerlink" title="为什么需要使用 vendor？"></a>为什么需要使用 vendor？</h4><p>vendor 目录允许不同的项目使用不同版本的依赖包，这做到了工程的隔离。</p><h4 id="govendor-status-types"><a href="#govendor-status-types" class="headerlink" title="govendor status types"></a>govendor status types</h4><table><thead><tr><th>code</th><th>description</th></tr></thead><tbody><tr><td>+local（l）</td><td>在项目中的包</td></tr><tr><td>+external（e）</td><td>引用的包在GOPATH之下，但是没有在vendor目录下</td></tr><tr><td>+vendor（v）</td><td>包在vendor目录中，已经被govendor管理</td></tr><tr><td>+std（s）</td><td>标注库中的包</td></tr><tr><td>+excluded（x）</td><td>引用的包被排除在GOPATH，没有在当前目录下</td></tr><tr><td>+unused（u）</td><td>这个包在vendor目录下，但是未使用</td></tr><tr><td>+missing（m）</td><td>有代码应用了这个包，但是找不到这个引用包</td></tr><tr><td>+program（p）</td><td>这个包是包含 main 包的目录</td></tr><tr><td>+outside</td><td>外部包和缺失的包</td></tr><tr><td>+all</td><td>所有的包</td></tr></tbody></table><p>以上的<code>status types</code> 会在执行 <code>govendor list</code> 会列出所有的包，并且能够看到项目中所有包的情况</p><h3 id="govendor-使用"><a href="#govendor-使用" class="headerlink" title="govendor 使用"></a>govendor 使用</h3><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>init</td><td>初始化，创建 vendor 目录和 vendor.json 文件</td></tr><tr><td>list</td><td>列出项目中所有的 包，包括自己的包</td></tr><tr><td>add</td><td>添加包到 vendor 目录，从 <code>$GOPATH</code> 中添加依赖包，会加到 <code>vendor.json</code> 中</td></tr><tr><td>update</td><td>从 <code>$GOPATH</code> 更新包到 vendor 目录</td></tr><tr><td>remove</td><td>从 vendor 管理中删除依赖包</td></tr><tr><td>status</td><td>列出所有缺失、过期、和修改过的包</td></tr><tr><td>fetch</td><td>从远程仓库中添加或更新一个包到 vendor 目录</td></tr><tr><td>sync</td><td>根据 vendor.json 记录的信息，从远程仓库中拉取包</td></tr><tr><td>get</td><td>类似于 <code>go get</code>， 拉取依赖包到 vendor 目录下</td></tr><tr><td>license</td><td>列出某个包的许可证</td></tr><tr><td>shell</td><td>运行一个shell，可以执行以上命令</td></tr></tbody></table><blockquote><p>go tool commands that are wrapped:<br>“+status” package selection may be used with them<br>fmt, build, install, clean, test, vet, generate, tool</p></blockquote><p>其他可以使用 <code>govendor --help</code> 来查看更多，更详细的命令，也可以通过 <a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">https://github.com/kardianos/govendor</a>，来查看信息。</p><blockquote><p>注意：项目目录（工作空间）必须在 <code>$GOPATH/src</code> 目录下，govendor 是用于管理项目依赖包的，如果 <code>$GOPATH</code> 下没有依赖包，则需要先下载。</p></blockquote><pre><code>cd &quot;my project in GOPATH&quot;govendor init# 将在 $GOPATH 下却没有在当前目录（vendor）下，加入到 vendor 目录。govendor add +external# govendor 会分析.go 为后缀的文件，分析出依赖包的状态govendor list # 列出指定的包在哪被使用了govendor list -v fmt# 从远程仓库中获取指定版本的包，也可以不指定版本，默认会获取最新版本govendor fetch github.com/gin-gonic/gin@v1.3# 格式化本地的包，并返回格式化了哪些包govendor fmt +local# build 本地的包govendor install +local# 只测试本地的包govendor test +local# 移除被 vendor 所管理的包govendor remove +v </code></pre><pre><code>$ govendor listpl  github.com/golearn/project l  github.com/golearn/project/tt  m github.com/gin</code></pre><p>前面是是状态类型，<code>pl</code> 代表的意思是：这个包是本地的包，并且包含了main包，也就是可以执行的包。<code>m</code> 代表的是这个包被引用了，但是找不到这个包。</p><pre><code>$ govendor list +&lt;status types&gt;$ govendor list +std s  fmt s  net s  net/http</code></pre><p>这个会列出项目中用到的标准库包；使用<code>govendor list +&lt;status types&gt;</code> 可以更精确的分析项目中依赖包的状态。</p><h4 id="govendor-报错"><a href="#govendor-报错" class="headerlink" title="govendor 报错"></a>govendor 报错</h4><pre><code>$ govendor initError: FindFirstFile C:\Users\ZAKI\Code\go\src\src: The system cannot find the file specified.</code></pre><p>原因：有多个GOPATH，没有指定GOPATH，导致报错。</p><p>解决方案：只能够删除掉不使用的GOPATH，才能够初始化成功。</p><pre><code>$ echo %GOPATH%C:\Users\ZAKI\Code\go;C:\Users\ZAKI\Code\go\src$ govendor initError: FindFirstFile C:\Users\ZAKI\Code\go\src\src: The system cannot find the file specified.</code></pre><pre><code>$ echo %GOPATH%C:\Users\ZAKI\Code\go$ govendor init</code></pre><p>当只有一个 GOPATH 的时候，创建vendor就成功了</p><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h3><p>在Go 1.11 中，官方加入了实验性的包管理工具（package management tool），称之为Modules。</p><p>其目的可能是：</p><ul><li>统一已有的第三方包管理工具</li><li>移除在 Go 1.5 版本引入的 vendor</li><li>移除 <code>$GOPATH</code></li></ul><h4 id="go-mod-指令介绍"><a href="#go-mod-指令介绍" class="headerlink" title="go mod 指令介绍"></a>go mod 指令介绍</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>download</td><td>将依赖全部下载到本地，位置为 <code>$GOPATH/pkg/mod/cache</code></td></tr><tr><td>edit</td><td>编辑 go.mod 例如锁定某个版本的依赖</td></tr><tr><td>graph</td><td>列出项目中那个部分使用了某个依赖</td></tr><tr><td>init</td><td>初始化创建 <code>go.mod</code></td></tr><tr><td>tidy</td><td>增加缺少的依赖，移除未使用的依赖</td></tr><tr><td>vendor</td><td>将所有的 go.mod 依赖全部存储在 <code>/vendor</code> 目录下</td></tr><tr><td>verify</td><td>验证本地依赖依然是预期的内容，就是符合<code>go.sum</code> 的</td></tr><tr><td>why</td><td>解释摸个依赖为何存在于 <code>go.mod</code> 中，为什么需要它</td></tr></tbody></table><p>在 <code>$GOPATH</code> 中使用 go mod 依然按照现有的 vendor 机制，除非修改环境变量 <code>GO111MODULE</code> 为 <code>on</code>，来强制开启它。</p><p>接下来我们就在<code>$GOPATH</code> 以外演示一下 go modules</p><pre><code>$ go mod init testgo: creating new go.mod: module test$ lsgo.mod</code></pre><p>会看见目录下多了一个 <code>go.mod</code> 文件，这个文件就是用来保存 go 的依赖的</p><pre><code>$ cat go.modmodule test</code></pre><p>下面来试着写一个简单的 hello world</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// main.go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"github.com/gofrs/uuid"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      uuid<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> uuid<span class="token punctuation">.</span><span class="token function">NewV4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">,</span> uuid<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这个hello world 中包含了外部包，首先确认，我们的 GOPATH 下没有这个包，然后我们开始吧。</p><pre><code>$ go run main.gogo: finding github.com/gofrs/uuid v3.2.0+incompatiblego: downloading github.com/gofrs/uuid v3.2.0+incompatiblehello world 0ffb8f8d-5019-407c-bfb5-f85fe64508f5</code></pre><p>go 自己去下载了第三方的包，并且保存到了 <code>$GOPATH/pkg/mod/cache</code> 目录下了；并且 ·<code>go.mod</code> 文件会记录下这个依赖</p><pre><code>$ cat go.modmodule testrequire github.com/gofrs/uuid v3.2.0+incompatible // indirect</code></pre><p>每次使用 go 的子命令，像 <code>go build</code>、<code>go run</code>、<code>go get</code>、<code>go test</code> 的时候，都会检查整个项目目录的依赖，并且自动更新到 <code>go.mod</code> 下。</p><h3 id="从已有的-vendor-转移到-go-modules"><a href="#从已有的-vendor-转移到-go-modules" class="headerlink" title="从已有的 vendor 转移到 go modules"></a>从已有的 vendor 转移到 go modules</h3><p>非常简单，只需要在项目目录下直接执行 <code>go mod init</code>即可</p><p>go 会自动去读取 <code>glide.yaml</code> 或是 <code>vendor/vendor.json</code> 并生成一个 <code>go.mod</code>。</p><p>可以试试：</p><pre><code>$ go mod tidy</code></pre><p>整个命令会帮助你移除没有使用的依赖。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> vendor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习</title>
      <link href="/2019/04/05/golang-learn/"/>
      <url>/2019/04/05/golang-learn/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Apr 07 2019 22:27:15 GMT+0800 (China Standard Time) --><h2 id="GO-基础学习"><a href="#GO-基础学习" class="headerlink" title="GO 基础学习"></a>GO 基础学习</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Go语言定义变量有好几种方式。</p><p>使用 <code>var</code>关键字是GO最基本定义变量的一种方式，与其他静态类型不一样的是<code>变量类型是写在变量之后的</code>，就像这样：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> variable <span class="token keyword">type</span> <span class="token comment" spellcheck="true">// var 是声明一个变量，这个是定义一个名字叫variable的变量，类型为type</span></code></pre><p>下面是几种变量定义的方式：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token comment" spellcheck="true">// 定义包内变量 并且在包内都可以使用</span><span class="token keyword">var</span> variableDefine <span class="token builtin">int</span> <span class="token comment" spellcheck="true">// 同样是定义包内变量，不用指定变量类型</span><span class="token keyword">var</span> helloWorld <span class="token operator">=</span> <span class="token string">"hello,world!"</span> <span class="token comment" spellcheck="true">// 在一个组内定义变量，可以用一个var定义多个不同类型变量</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    a <span class="token builtin">string</span>    b <span class="token builtin">int</span>    c <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用var同时初始化多个变量，变量类型自动推断，这种方式十分舒服</span>    <span class="token keyword">var</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v3 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.1415</span><span class="token punctuation">,</span> <span class="token string">"hello"</span>    <span class="token comment" spellcheck="true">// 一个var只能指定一种变量类型</span>    <span class="token keyword">var</span> va1<span class="token punctuation">,</span> va2<span class="token punctuation">,</span> va3 <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"va1"</span><span class="token punctuation">,</span> <span class="token string">"va2"</span><span class="token punctuation">,</span> <span class="token string">"va3"</span> <span class="token punctuation">}</span></code></pre><p>还有一种方式，只能够在函数内使用，在函数外部使用会导致编译不通过，一般定义全局变量使用<code>var</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token comment" spellcheck="true">// 错误！这种定义方式不能够使用在此处</span>varable <span class="token operator">:=</span> <span class="token string">"hello,world"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 正确！在函数内部，才能够使用这种便利的方式定义变量，不需要指定变量类型</span>    variable <span class="token operator">:=</span> <span class="token string">"hello,world"</span>    <span class="token comment" spellcheck="true">// 这是同时定义多个不同的类型的变量</span>    var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var3 <span class="token operator">:=</span> <span class="token string">"var1"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">}</span></code></pre><p><code>_</code>（下划线，不需要定义）是一个特殊的变量，go语言所有定义的变量都必须使用，而有的变量是不需要的，例如<code>for range</code> 只想要 value 而不要 index，就可以使用下划线来将其丢弃。</p><p>如果定义了一个变量，没有被使用，那么将会报错</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span><span class="token punctuation">}</span></code></pre><p>就像下面这样，定义了一个变量 i 却没有使用</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># command-line-arguments</span>src\gd\client.go:12:2: i declared and not used</code></pre><p>如果像下面这样：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> i <span class="token builtin">int</span>    <span class="token boolean">_</span> <span class="token operator">=</span> i<span class="token punctuation">}</span></code></pre><p>这样就不会报错了，因为，将i赋值给<code>_</code>变量，会将i丢弃，这样i也使用了，就不会报错。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在go语言中，可以定义为常量的类型有：布尔型、rune型、整数型、浮点型、复数型还有字符型，rune、integer、floating-point,还有complex统称为数值常量。</p><blockquote><p>There are <em>boolean constants</em>, <em>rune constants</em>, <em>integer constants</em>, <em>floating-point constants</em>, <em>complex constants</em>, and <em>string constants</em>. Rune, integer, floating-point, and complex constants are collectively called <em>numeric constants</em>.</p></blockquote><p>常量的定义方法：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> constantName <span class="token operator">=</span> value<span class="token comment" spellcheck="true">// 如果有需要，也可以明确指定数据类型</span><span class="token keyword">const</span> Pi <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">3.1415926</span><span class="token keyword">const</span> Pi <span class="token operator">=</span> <span class="token number">3.1415926</span> <span class="token keyword">const</span> MaxNum <span class="token builtin">int</span><span class="token operator">=</span> <span class="token number">10000</span><span class="token keyword">const</span> prefix <span class="token operator">=</span> <span class="token string">"db_"</span></code></pre><h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><p>在GO语言中，内置了丰富的基础类型。</p><h4 id="Boolean-布尔型"><a href="#Boolean-布尔型" class="headerlink" title="Boolean (布尔型)"></a>Boolean (布尔型)</h4><p>布尔型的类型为 <code>bool</code> ，值是<code>true</code> 或 <code>false</code> ，默认零值为<code>false</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">var</span> isActive <span class="token builtin">bool</span>           <span class="token comment" spellcheck="true">//声明全局变量</span><span class="token keyword">var</span> enabled<span class="token punctuation">,</span> disabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span>   <span class="token comment" spellcheck="true">// 忽略类型的声明</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> avilable <span class="token builtin">bool</span>                <span class="token comment" spellcheck="true">// 一般声明</span>    valid <span class="token operator">:=</span> <span class="token boolean">false</span>                   <span class="token comment" spellcheck="true">// 简短声明</span>    available <span class="token operator">:=</span> <span class="token boolean">true</span>                  <span class="token comment" spellcheck="true">// 赋值操作</span><span class="token punctuation">}</span></code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 学习【转载】</title>
      <link href="/2019/04/05/mysql/"/>
      <url>/2019/04/05/mysql/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Apr 07 2019 22:27:15 GMT+0800 (China Standard Time) --><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><blockquote><p>MySQL 的基本操作可以包括两个方面: MySQL 常用语句如高频率使用的增删改查(CRUD)语句和 MySQL 高级功能, 如存储过程, 触发器, 事务处理器等. 而这两个方面又可以细分如下:</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007Ie89nly1g1t17iconcj30td0qojru.jpg" alt="mysql"></p><h4 id="Mysql-常用语句"><a href="#Mysql-常用语句" class="headerlink" title="Mysql 常用语句"></a>Mysql 常用语句</h4><ol><li>表（或者数据库）的 CRUD。</li><li>表数据的 <code>CRUD</code>，其中表数据查询使用最多，也更复杂。查询可以按照单表还是多表可以分为： 单表<code>SELECT</code>查询和夺标的连接查询（<code>INNER JOIN</code>，<code>LEFT JOIN</code>，<code>RIGHT JOIN</code>和<code>FULL JOIN</code>）以及组合查询<code>UNION</code>以及组合查询<code>UNION</code>和<code>UNION ALL</code>。</li><li>SQL 语句中各个关键字的执行顺序。</li></ol><h2 id="1-表（或数据库）操作语句"><a href="#1-表（或数据库）操作语句" class="headerlink" title="1. 表（或数据库）操作语句"></a>1. 表（或数据库）操作语句</h2><h4 id="1-1-查询表（或数据库）"><a href="#1-1-查询表（或数据库）" class="headerlink" title="1.1 查询表（或数据库）"></a>1.1 查询表（或数据库）</h4><ol><li><strong>获取所有可用的数据库：</strong> <code>SHOW DATABASES</code>。</li><li><strong>选择数据库：</strong><code>USE &lt;databaseName&gt;</code>。</li><li><em>用于显示数据库服务器状态信息：</em><code>SHOW STATUS</code>。</li><li><em>用来显示授权用户的安全权限：</em> <code>SHOW GRANTS</code>。</li><li><em>用来显示数据服务器或警告信息：</em> <code>SHOW ERRORS</code> 或者<code>SHOW WARNINGS</code>。</li><li><strong>用于显示创建数据库是的创建语句：</strong> <code>SHOW CREATE DATABASE &lt;databaseName&gt;</code>。</li><li><strong>用于显示创建表示的创建语句：</strong> <code>SHOW CREATE DATABASE &lt;tableName&gt;</code>。</li><li><strong>获取当前所选的数据库中所有可用的表：</strong> <code>SHOW TABLES</code> 。</li><li><strong>获取表中所有列的信息：</strong> <code>SHOW COLUMNS FROM &lt;tableName&gt;</code>；<code>DESCRIBE</code> 语句也具有相同的效果： <code>DESCRIBE &lt;tableName&gt;</code>。</li></ol><h3 id="1-2-新建表或数据库"><a href="#1-2-新建表或数据库" class="headerlink" title="1.2 新建表或数据库"></a>1.2 新建表或数据库</h3><ol><li><em>新建数据库：</em> <code>CREATE DATABASE &lt;databaseName&gt;</code>。</li><li><strong>创建表可以使用 <code>CREATE TABLE</code> 语句:</strong></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> customers <span class="token punctuation">(</span>    cust_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    cust_name CHAR<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    cust_age <span class="token keyword">INT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">18</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span><span class="token punctuation">;</span></code></pre><h6 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h6><ol><li>允许 <strong>NULL</strong> 值， 则说明再插入行数据时允许不给出该列的值，而 <strong>NOT NULL</strong> 则表示在插入或更新该列数据，必须明确给出该列的值。</li><li><strong>DEFAULT</strong>表示该列的默认值，在插入行数据时，若没有给出该列的值就会使用其指定的默认值；</li><li><strong>PRIMARY KEY</strong> 用于指定主键，主键可以指定一列数据，而可以由多列数据组合构成，如 <code>PRIMARY KEY(cust_id, cust_name)</code>;</li><li><strong>ENGINE</strong> 用于指定引擎类型。<br>常见的引擎类型又这些：<br>（1）InnoDB 是一个支持可靠的事务处理的引擎，但是不支持全文本搜索；<br>（2）MyISAM 是一个新能极高的引擎，它支持全文本搜索，但不支持事务处理；<br>（3）MEMORY 在功能上等同与 MyISAM，由于数据存储在内存中，速度很快（特别适何临时表）；</li></ol><p>3.在创建表的时候可以使用 <strong>FOREING KEY</strong> 来创建外键，即一个表中的<code>FOREING KEY</code><br>指向另一个表中的 <strong>PRIMARY KEY</strong>。外键 <strong>FOREING kEY</strong>用于约束破坏表的联结（连接）动作，保证连个表的数据完整性。同时也能防止非法数据插入外键列，因为该列值必须指向另一个表的主键。实例如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Orders <span class="token punctuation">(</span>    Id_O <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    OrderNo <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    Id_P <span class="token keyword">int</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Id_O<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Id_P<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Persons<span class="token punctuation">(</span>Id_P<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="1-3-删除表或数据库"><a href="#1-3-删除表或数据库" class="headerlink" title="1.3 删除表或数据库"></a>1.3 删除表或数据库</h3><ol><li><strong>删除数据库：</strong> <code>DROP DATABASE &lt;databaseName&gt;</code>。</li><li><strong>删除表：</strong> <code>DROP TABLE &lt;tableName&gt;</code>。</li></ol><h3 id="1-4-更新表"><a href="#1-4-更新表" class="headerlink" title="1.4 更新表"></a>1.4 更新表</h3><ol><li>更新表结构信息可以使用 <strong>ALTER TABLE</strong> 字句，如为表怎加一列：<br><code>ALTER TABLE vendors ADD vend_name CHAR(20)</code>。另外进场用于定义外键，如：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> customers<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> fk_custormer_orders  <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span><span class="token keyword">REFERENCES</span> orders <span class="token punctuation">(</span>order_cust<span class="token punctuation">)</span></code></pre><ol start="2"><li>重命名表， 使用 <code>RENAME</code> 子句。 <code>RENAME TABLE backup_customers TO customers, backup_vendors TO vendors</code>；更改多个表名，之间用逗号间隔。</li></ol><h2 id="2-表数据操作语句"><a href="#2-表数据操作语句" class="headerlink" title="2 表数据操作语句"></a>2 表数据操作语句</h2><h3 id="2-1-查询表数据"><a href="#2-1-查询表数据" class="headerlink" title="2.1 查询表数据"></a>2.1 查询表数据</h3><blockquote><p>基本操作语句</p></blockquote><ol><li><p>根据过滤条件春训表中的单列或者多列或者全部列的信息 <strong>SELECT FROM WHERE：</strong> <code>SELECT cust_id, cust_name, FROM customers WHERE cust_id=10000</code>;<br>其中，过滤条件操作符有： <code>=, &lt;&gt;, !=, &lt;, &lt;=, &gt;, &gt;=</code> 和 <code>BETWEEN AND, IS NULL</code>;</p></li><li><p>为查询出的某一列信息去重 <strong>DISTINCT：</strong><br><code>SELECT DISTINCT cust_name FROM customers</code>;</p></li><li><p>限制单列查询结果的行数： <code>SELECT cust_name FROM customers LIMIT 5</code>; <em>LIMIT</em>后跟一个数值，表示从第 0 行开始取，共取 5 行数据；如果 <strong>LIMIT 5,5</strong> 表示从第 6 行（数据库中行数是从 0 开始的，所以是第 6 行）开始取，共取 5 行数据。</p></li></ol><p>4.　<strong>ORDER BY</strong> 子句取一个或者多个列，据此对输出进行排序：<br><code>SELECT cust_id, cust_name FROM customers ORDER BY cust_id DESC, cust_name</code>；</p><ol start="5"><li><p><strong>IN</strong> 操作符用来指定条件范围，范围中的每个条件都可以进行匹配：<br><code>SELECT cust_id, cust_name FROM customers WHERE cust_id IN (10000, 20000)</code>；</p></li><li><p><strong>LIKE</strong> 操作符用来表明模糊查询，与之配合使用的通配符有 <strong><code>% _</code></strong>，<code>%</code> 表示任何字符出现任何次数； <strong>_</strong> 表示匹配一个字符：<br><code>SELECT cust_id, cust_name FROM customers WhERE cust_name LIKE &#39;%happy%&#39;</code>;</p></li><li><p>使用分组查询并可以满足一定的分组过滤条件 <strong>GROUP BY HAVING</strong>。如检索总计订单金额大于 50 的订单号和订单总金额，并按总金额进行排序：<br><code>SELECT order_num, SUM(quantity * item_price) AS order_total FROM orderitems GROUP BY order_num HAVING SUM(quantity * item_price) &gt;= 50 ORDER BY order_total</code>;</p></li><li><p><strong>WHERE</strong> 和 <strong>HAVING</strong> 的比较。<em>WHERE</em> 是行级过滤，而 <em>HAVING</em> 组级过滤。被 <em>WHERE</em> 过滤掉的数据不会出现在分组中。 <em>WHERE</em> 中通配符以及多个 <em>WHERE</em> 子句的连接同样适用于 <em>HAVING</em> 子句；</p></li><li><p><strong>GROUP BY</strong> 的使用注意事项：<br>（1）<code>GROUP BY</code> 子句中可以嵌套分组（即通过多个列进行分组 <code>GROUP BY cust_id, cust_name</code>），但是尽心数据汇总时，是在最后规定的分组上进行；<br>（2）<code>GROUP BY</code> 子句中列出的每个列都必须时检索列或者时有效的表达式。<br>（3）如果有 <em>NULL</em> 值，将 <em>NULL</em> 值作为一个分组尽心返回，若果有多行 <em>NULL</em> 值，他们将分为一组。</p></li><li><p>嵌套其他查询中的查询，被称之为 <strong>子查询</strong>。执行过程由里向外，里层查询结作为外层查询的条件：<br><code>SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &#39;happy&#39;)</code>；当然，多表的查询可以是用联结（连接）查询。</p></li></ol><blockquote><p>联结（连接）查询</p></blockquote><ol><li>内联结又称之为内部联结，是基于两个表之间的相等测试。如果不加过滤条件，会造成 <a href="https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF" target="_blank" rel="noopener"><em>笛卡尔积</em></a>。<br><code>SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id</code>;同样可以使用 <code>WHERE</code> 子句进行多表联结查询，但是更推荐使用 <code>INNER JOIN</code> 等联结方式；</li><li>外部链接包括左外联结 <strong><code>LEFT JOIN</code></strong> 和右外联结 <strong><code>RIGHT JOIN</code></strong>。例如查询每个客户的订单数：<code>SELECT customers.cust_id, orders.orders_num FROM customers LEFT JOIN orders ON orders.cust_id = customers.cust_id</code>；<em>LEFT JOIN</em> 会全部返回坐标数据，<em>RIGHT JOIN</em> 会全部返回右表数据，<em>FULL JOIN</em>会将左右两个表的数据全部返回；</li><li>联合查询与聚集函数一起使用。如查询每个客户的订单数：<br><code>SELECT customers.cust_name, customers.cust_id, COUNT(order.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id = orders.cust_id GROUP BY customers.cust_id</code>;</li></ol><blockquote><p>组合查询</p></blockquote><ol><li><p>多个查询（<strong>SELECT</strong>）可以使用 <strong>UNION</strong> 将多个查询结果尽心合并成一个结果集返回，<strong>UNION</strong> 必须宝行两个及两个以上的 <strong>SELECT</strong> 查询，斌且每个毕珣宝行相同的列、表达式或聚集函数，数据类型不必完全相同，<strong>MySQL</strong> 会进行隐式的类型转换。</p></li><li><p><strong>UNION</strong> 返回的是去重后的结果，如果不需要去重则可以使用 <strong>UNION ALL</strong>；</p></li><li><p>可以多组合查询使用 <strong>ORDER BY</strong> 进行排序,但是是针对最终的结果集进行排序,而不是其中单个 <strong>SELECT</strong> 查询进行排序, 因此对于组合查询来说 <strong>ORDER BY</strong> 子句只有一个。<br><code>SELECT vend_id， prod_id, prod_price FROM products WHERE prod_price &gt; 5 UNION SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN(1001, 1002) ORDER BY vend_id</code>；</p></li></ol><blockquote><p>使用函数对数据进行处理</p></blockquote><ol><li><p>拼接列名：<br><code>SELECT Concat (vendName, &#39;(&#39;vendCountry,&#39;)&#39;) From vendors ORDER BY vendName</code>;</p></li><li><p>执行算数表达式计算：<br><code>SELECT prodId, quantity, price, quantity * price AS expandedPrice FROM ORDERiTEMS</code>;</p></li><li><p>文本处理函数如 Upper(), LTrim()等函数。 比如使用 Upper 函数将文本转换成大写：<br><code>SELECT vendName, Upper(vendName) FROM vendors ORDER BY vendName</code></p></li><li><p>时间和日期处理函数，如 Date(), Day()等。<br><code>SELECT COUNT(*) AS numbers, MIN(prod_price) AS price_min,MAX(PROD_PRICE) AS price_max, AVG(prod_price) AS price_avg FROM products</code>;</p></li><li><p>数值处理函数，如 ABS(),COS()等；</p></li><li><p>常用的聚集函数。如 AVG(),COUNT(),MAX(),MIN()以及 SUM()。<br><code>SELECT COUNT(*) AS numbers, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avg FROM products</code>;</p></li></ol><h3 id="插入表数据"><a href="#插入表数据" class="headerlink" title="插入表数据"></a>插入表数据</h3><ol><li>向表中插入行数据可以使用 <strong>INSERT INTO</strong> 子句，更安全的方式是指定列名。 <code>INSERT INTO customers (cust_name, cust_email) VALUES (&#39;happy&#39;, &#39;happy@gmail.com&#39;);</code> 在 <strong>INSERT INTO</strong> 子句中能够省略列名的前提条件是：该列可以允许定义为 NULL 值或者在定义时给出去了默认值；</li><li>如果插入多行数据可以将多组值用逗号进行分隔即可。<br><code>INSERT INTO customers (cust_name, cust_email) VALUES (&#39;happy&#39;, &#39;happy@gmail.com&#39;),(&#39;smart&#39;, &#39;smart@gmail.com&#39;);</code></li><li>将查询出来的数据插入表中，可以使用 <strong>INSERT SELECT</strong> 语句。<br><code>INSERT INTO customers(cust_id, cust_contact) SELECT cust_id, cust_conntact FROM customer WHERE cust_id &gt; 5;</code> 其中 SELECT 中可以带 WHERE 过滤条件；<strong>INSERT SELECT</strong>通常被用于复制表数据。</li></ol><h3 id="更新表数据"><a href="#更新表数据" class="headerlink" title="更新表数据"></a>更新表数据</h3><ol><li>如果要更新表数据的话，使用 <strong>UPDATE</strong> 子句：<br><code>UPDATE customers SET cust_name = &#39;happy&#39;, cust_email = &#39;happy@gmail.com&#39; WHERE cust_id = 1001;</code></li><li>注意： 如果不加 <strong>WHERE</strong> 条件指定到某一行的话，会更新表中某一列的全部的数据。</li></ol><h3 id="删除表数据"><a href="#删除表数据" class="headerlink" title="删除表数据"></a>删除表数据</h3><ol><li>如果从表中删除数据的话，可以使用 <strong>DELETE</strong> 子句。<br><code>DELETE FROM customers WHERE cust_id = 10086;</code><br>删除的数据必定是表中行数据，而不是某一列。因此，与 <strong>UPDATE</strong> 子句相比，<strong>DELETE</strong> 子句并不需要指定是哪一列，而仅仅只需要指定具体的表明即可；</li><li><strong>注意： 如果不添加 WHERE 指定条件的话，会将整个表中的所有行数据全部删除。另外，DELETE 只是删除表中的数据，而不会删除表结构信息；</strong></li><li>如果想删除表中的全部的数据，可以使用 <strong>TRUNCATE</strong>，比 <strong>DELETE</strong> 删除效率更高；</li></ol><h2 id="SQL-中关键字执行顺序"><a href="#SQL-中关键字执行顺序" class="headerlink" title="SQL 中关键字执行顺序"></a>SQL 中关键字执行顺序</h2><p>在 SQL 语句中每个关键字都会按照顺序往下执行，而每一步操作，都会生成一个虚拟表，最后产生的虚拟表会作为执行的最终结果返回。下面的是常用的关键字的执行顺序：</p><pre><code>(1)FROM &lt;left_table&gt;(2)ON &lt;join_condition&gt;(3)&lt;join_type&gt; JOIN &lt;right_table&gt;(4)WHERE &lt;where_condition&gt;(5)GROUP BY&lt;group_by_list&gt;(6)WITH{CUBE|ROLLUP}(7)HAVING&lt;having_condition&gt;(8)SELECT(9)DISTINCT&lt;select_list&gt;(10)ORDER BY&lt;order_by_list&gt;(11)LIMIT&lt;limit_number&gt;</code></pre><ol><li><strong>FROM</strong>：对 FROM 左边的表和邮编的表计算笛卡尔积，产生虚拟表 VT1；</li><li><strong>ON</strong>：对虚拟表 VT1 进行 ON 筛选，只有那些符合&lt;join_condition&gt; 条件的行才会被记录在虚拟表 VT2 中；</li><li><strong>JOIN</strong>：如果是 OUT JOIN，name 将保留表中（如左表或者右表）未匹配的行作为外部行添加到虚拟表 VT2 中，从而产生虚拟表 VT3；</li><li><strong>WHERE</strong>：对虚拟表 VT3 进行 WHERE 条件过滤，只有符合&lt;where_condition&gt;的记录才会别放入到虚拟表 VT4；</li><li><strong>GROUP BY</strong>：根据 GROUP BY 子句中的列，对虚拟表 VT4 进行分组操作，产生虚拟表 VT5；</li><li><strong>CUBE | ROLLUP</strong>：对虚拟表 VT5 进行 CUBE 或者 ROLLUP 操作，产生虚拟表 VT6；</li><li><strong>HAVING</strong>：对虚拟表 VT6 进行 HAVING 条件过滤，只有符合&lt;having_condition&gt;的记录才会别插入到虚拟表 VT7 中；</li><li><strong>SELECT</strong>：执行 SELECT 操作，选择指定的列，插入到虚拟表 VT8 中；</li><li><strong>DISTINCT</strong>：对虚拟表 VT8 中的记录进行去重，产生虚拟表 VT9；</li><li><strong>ORDER BY</strong>：将虚拟表 VT9 中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表 VT10；</li><li><strong>LIMIT</strong>：取出指定行的记录，产生虚拟表 VT11，并将结果返回。</li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>MySQL 缩影的简历对于 MySQL 的高效运行是很重要的，索引可以大大提高 MySQL 的检索速度。索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，而组合索引，即一个索引包含多个列。</p></blockquote><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>创建索引有两种方式，一种是直接利用 <strong>CREATE INDEX</strong>进行创建，另外一种则是通过修改表结构来进行添加，则是利用 <strong>ALTER TABLE</strong>语句。</p><ol><li><p>使用<code>CREATE INDEX</code></p><p>语法为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span><span class="token operator">|</span>FULLTEXT<span class="token operator">|</span>SPATIAL<span class="token punctuation">]</span><span class="token keyword">INDEX</span> index_name<span class="token punctuation">[</span><span class="token keyword">USING</span> index_type<span class="token punctuation">]</span><span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>index_col_name<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></code></pre><p>其中对应的语法变量信息如下：</p><blockquote><p>[UNIQUE | FULLTEXT | SPATIAL]</p></blockquote><p>其中括号中的这三个关键字表示创建索引类型，他们分别表示 <strong>唯一索引，全文索引，空间索引</strong> 三种不同的索引类型。如果我们不指定任何关键字，则默认为普通索引。</p><blockquote><p>index_name</p></blockquote><p><code>index_name</code> 表示索引的名称，又用户自行定义，仪表与以后对该索引进行管理操作。</p><blockquote><p>index_type</p></blockquote><p><code>index_type</code> 表示索引的具体实现凡是，在 MySQL 中，有两种不同形式的索引 —— <strong>BTREE</strong> 索引和 <strong>HASH</strong> 索引。在存储引擎为 <strong>MyISAM</strong> 和 <strong>InnoDB</strong> 的表中只能使用 BTREE，其默认值就是 BTREE；在存储引擎为 MEMORY 或者 HEAP 的表中可以使用 HASH 和 BTREE 两种类型的索引，其默认值为 HASH。</p><blockquote><p>index_col_name</p></blockquote><p><code>index_col_name</code> 表示需要创建索引的字段名称，我们还可以针对多个字段创建复合索引，只需要多个字段名称之间以英文逗号隔开即可。此外，对于 CHAR 或者 VARCHAR 类型的字段，我们还可以值使用字段内容前面的一部分来闯进啊索引，只需要在对应的字段名称后米昂加上形如（<em>length</em>）的指令即可，表示只需要使用字段内容前面的 <em>length</em> 个字符来创建索引。在这里我们以 customers 表的 cust_name 字段（类型为 VARCHAR（50））为例，使用 cust_name 字段的 6 个字符前缀来创建索引。</p><pre><code>CREATE INDEX idx_cust_name ON user (cust_name(6));</code></pre></li><li><p>使用 ALTER TABLE</p><p>语法为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_nameADO <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span><span class="token operator">|</span>FULLTEXT<span class="token operator">|</span>SPATIAL<span class="token punctuation">]</span><span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>index_col_name<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token keyword">USING</span> index_type<span class="token punctuation">]</span></code></pre></li></ol><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>删除指定表中的特定名称的索引，语法为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">;</span></code></pre><p>例如删除名称为 idx_cust_name 的索引，其 SQL 语句为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> customers<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> idx_cust_name<span class="token punctuation">;</span></code></pre><h3 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h3><p>在 MySQL 中并没有提供修改索引的直接指令，一般情况下，我们需要先删除掉元索引，再根据需要创建一个同名的索引，从而变相的实现修改索引的操作。</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 先删除索引</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> idx_user_username<span class="token punctuation">;</span><span class="token comment" spellcheck="true">--  再以修改后的内容创建同名索引</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_cust_name <span class="token keyword">ON</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p>再 MySQL 中，要查看某个数据库表中的索引也非常简单，只需要使用一下两个命令中的任意一种即可。</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 如果查看索引前，没有使用 use db_name 等命令指定具体的数据库，则必须加上 FROM db_name</span><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> table_name <span class="token punctuation">[</span><span class="token keyword">FROM</span> db_name<span class="token punctuation">]</span><span class="token comment" spellcheck="true">-- 如果查看索引前，没有使用 use db_name 等命令指定具体的数据库，则必须加上 db_name. 前缀</span><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> <span class="token punctuation">[</span>db_name<span class="token punctuation">.</span><span class="token punctuation">]</span>table_name</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><ol><li><p>什么是存储过程？存储过程简单的来说，就是为了复用性或者实现复杂的业务功能，而保存的一条或者多条 MySQL 语句的集合，可将其视为批文件；</p></li><li><p>为什么使用存储过程？<br>（1）通过把处理封装在容易使用的单元中，简化复杂的操作；<br>（2）由于不要求反复建立一系列的处理步骤，这保证了数据的完整性，如果所有的开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的；<br>（3）简化对变动的管理。如果表名、列名或业务逻辑有变化，只需要更改存储过程的代码，使用它的开发人员升值不需要知道这些变化，也就是具备了安全性；<br>（4）提高了性能，因为使用存储过程单独使用 SQL 语句要快；<br>（5）存储过程可用来编写功能更灵活的代码。因此，存储过程的具备三个特性： <strong>简单可复用、安全、高性能</strong>；</p></li><li>存储过程的缺点？<br>（1）存储过程编比基本的 SQL 语句更加复杂，需要更高的技能；<br>（2）可能没有创建存储过程的权限，数据库管理员可能会限制存储过程的权限，允许用户使用存储过程，而不允许用户自由创建存储过程；</li></ol><blockquote><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4></blockquote><ol><li>创建存储过程。如需要统计用户订单总金额，如果该用户需要交税的话，订单总金额则需要再加上税费：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELIMITER</span> <span class="token comment" spellcheck="true">//</span> <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">(</span> <span class="token operator">IN</span> custid <span class="token keyword">INT</span><span class="token punctuation">,</span> <span class="token operator">IN</span> taxable <span class="token keyword">BOOLEAN</span><span class="token punctuation">,</span> <span class="token keyword">OUT</span> ototal <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token keyword">COMMENT</span> <span class="token string">'obtain total order price'</span> <span class="token keyword">BEGIN</span> <span class="token comment" spellcheck="true">/*declare variable for total*/</span> <span class="token keyword">DECLARE</span> total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">DECLARE</span> taxrate <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*get the order total*/</span> <span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>item_price<span class="token operator">*</span>item_quantity<span class="token punctuation">)</span> <span class="token keyword">INTO</span> total <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> custid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*is this taxable?*/</span> <span class="token keyword">IF</span> taxable <span class="token keyword">THEN</span>     <span class="token keyword">SELECT</span> total<span class="token operator">+</span><span class="token punctuation">(</span>total<span class="token operator">/</span><span class="token number">100</span><span class="token operator">*</span>taxrate<span class="token punctuation">)</span> <span class="token keyword">INTO</span> total<span class="token punctuation">;</span> <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span> <span class="token keyword">SELECT</span> total <span class="token keyword">INTO</span> ototal<span class="token punctuation">;</span> <span class="token keyword">END</span> <span class="token comment" spellcheck="true">//</span></code></pre><p>有这样的一些细节：</p><ol><li>使用 <code>CREATE PROCEDURE</code> 语句进行创建，()圆括号中为存储过程的参数，其中参数类型有：<ol><li><strong>IN</strong> 类型，表示传递给存储过程；</li><li><strong>OUT</strong> 类型，表示存储过程返回的结果，在调用存储过程是需要传入@开始的变量；</li><li><strong>INOUT</strong> 类型，表示在存储过程中可以传入和传出；</li></ol></li><li><em>DECLARE</em> 用力啊生命一个变量，如这里的 total，taxrate。注意 MySQL 中定义变量时都是变量名在前，数据类型在后。</li><li>存储过程具体逻辑写在 <em>BEGIN END</em> 之间；</li><li>将值付给变量使用 <em>INTO</em> 关键字；</li><li>由于存储过程中每个 SQL 语句中用 <code>;</code> 作为分隔符，回合单个 SQL 造成冲突，因此可以使用 <em>DELIMITER</em> 重新定义分类符，如该例子中定义 <code>//</code> 作为分隔符，自然存储过程结尾就用 <code>END //</code> 结尾，而不再是 END。同时，分隔符 <code>//</code> 成对出现后，回复到默认的 <code>;</code> 作为分隔符；</li></ol><blockquote><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4></blockquote><ol><li>使用 <em>CALL</em> 子句执行存储过程， <em>CALL</em> 子句接受存储过程的名称以及需要传递的参数。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CALL</span> ordertotal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">TRUE</span><span class="token punctuation">,</span> <span class="token variable">@total</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token variable">@total</span><span class="token punctuation">;</span></code></pre><p>如果存储过程中定义了 OUT 类型的输入参数，那么在执行存储过程时需要传入变量，如这里的@total，并且变量都是用@开始的。如果存储过程中么有参数的话，就用空圆括号表示即可：<br><code>CALL ordertotal()</code>；</p><blockquote><h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4></blockquote><p>删除存储过程，可以使用 <em>DROP PROCEDURE</em> 子句。如：<br><code>DROP PROCEDURE ordertotal</code>；</p><blockquote><h4 id="查询存储过程"><a href="#查询存储过程" class="headerlink" title="查询存储过程"></a>查询存储过程</h4></blockquote><ol><li>显示创建一个存储过程的语句，可以使用 <em>SHOW CREATE PROCEDURE</em>。如：<br><code>SHOW CREATE PROCEDURE ordertotal</code>；</li><li>查询所有存储过程的状态，如果在定义存储过程中时用 <em>COMMENT</em> 添加注释，可以查看。同时可以 LIKE 进行过滤结果。如：<br><code>SHOW PROCEDURE STATUS LIKE &#39;%ORDER%&#39;</code>；</li></ol><h2 id="事物处理"><a href="#事物处理" class="headerlink" title="事物处理"></a>事物处理</h2><ol><li><p>什么是事务？<br>事务处理是用来维护数据库的完整性，它保证成批的 MySQL 操作要么完全执行，要么完全不执行。事务处理是一种机制，用来管理必须成批执行的 MySQL 操作，它们要么是作为整体执行或者完全不执行。</p></li><li><p>关键概念：</p><ol><li>事务：是指一组 SQL 语句；</li><li>回退：是指撤销指定的 SQL 语句的过程；</li><li>提交：指将为存储的 SQL 语句的结果写入数据库表中；</li><li>保留点：指事务处理中设置的临时占位符，可以对他发布回退；</li></ol></li><li><p>如何执行事务？</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> item_quantity<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> customers<span class="token punctuation">;</span><span class="token keyword">SAVEPOINT</span> insertinto<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> item_price<span class="token punctuation">,</span> item_quantity<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> insertinto<span class="token punctuation">;</span></code></pre><p>执行结果为：插入数据（’1’, 5, 18)有效，因为，只会从保留点 SAFEPOINT 之后开始回退，也就是说保留点 SAFEPOINT 之前的 SQL 语句执行的结果仍然有效。</p><p>有这样一些细节：</p><ol><li><strong>START TRANSACTION</strong> 用来表示下面的 SQL 语句集为一段事务；</li><li><strong>SAFEPOINT</strong> 用于指定保留点 insertinto；</li><li><strong>ROLLBACK TO</strong> 表示草你个指定保留点开始回退，也就是说保留点之前的 SQL 语句执行结果任然有效。如果仅仅使用 ROLLBACK 进行回退的话就表示从 START TRANSACTION 之后所有的 SQL 语句执行效果都会撤销；</li></ol></li><li><p>MySQL 提交（写或保存）操作室自动进行的，这称之为隐含提交。但是在事务处理块中，提交不会隐含进行，要使用 <em>COMMIT</em> 子句进行提交。如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> item_price<span class="token punctuation">,</span> item_quantity<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> item_price<span class="token punctuation">,</span> item_quantity<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">COMMIT</span><span class="token punctuation">;</span></code></pre><p>采用 <em>COMMIT</em> 提交事务，如果两条 SQL 语句都执行成功，才会将数据都写入表中。</p></li></ol><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><ol><li><p>什么是触发器？</p><p>当某条 SQL 语句发生时，自动执行某些其他的 SQL 语句的时候就需要使用触发器。触发器只能响应： <strong>DELETE，INSERT，UPDATE</strong> 这三个特定操作。</p></li><li><p>如何创建触发器？</p><p>创建触发器时需要给出最重要的四条信息：</p><ol><li>全局唯一的触发器名；</li><li>触发器关联的表；</li><li>触发器在合适执行（操作执行之前或者之后）</li><li>触发器应该响应的活动（<em>DELETE，INSERT，UPDATE</em>）；</li></ol><p>由于触发器只能响应特定的三种类型的操作，因此可闯进啊的触发器也就三种类型：<strong>INSERT</strong>触发器，<strong>DELETE</strong>触发器，以及 <strong>UPDATE</strong>触发器。</p><blockquote><h4 id="INSERT-触发器"><a href="#INSERT-触发器" class="headerlink" title="INSERT 触发器"></a>INSERT 触发器</h4></blockquote><p>在执行 INSERT 触发器时，有这样几点需要注意：</p><ol><li>在 INSERT 触发器代码内，可以引用一个名为 NEW 的虚拟表，可以用 NEW 来访问刚插入的行数据；</li><li>在 BEFORE INSERT 触发器中，NEW 中的值可以被更新；</li><li>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含 0，在 INSERT 执行之后包含行的自定生成值。</li></ol><p>创建一个 INSERT 触发器，每次插入一行数据，每次会返回单签常茹的行数据的 id：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/*创建触发器*/</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> insertcustomers <span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> customers<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span> NEW<span class="token punctuation">.</span>cust_id <span class="token keyword">INTO</span> <span class="token variable">@newinsertid</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*执行触发器*/</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers （cust_name<span class="token punctuation">,</span> item_price<span class="token punctuation">,</span> item_quantity<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token variable">@newinsertid</span><span class="token punctuation">;</span></code></pre><p>有这样一些细节：</p><ol><li>使用 <em>CREATE TRIGGER</em> 来创建触发器；</li><li><em>AFTER INSERT</em> 表明在插入行数据之后，触发器才会执行特定操作；</li><li><em>FOR EACH ROW</em> 表示对插入的每一行数据，触发器都起作用；</li><li>针对 INSERT 触发器，可以使用虚拟表 NEW，来使用刚插入的行数据。比如例子中：<br>`SELECT NEW.cust_id INTO @newinsertid 表示将新插入的行数据的 id 赋值给变量@newinsertid；</li></ol><blockquote><h4 id="DELETE-触发器"><a href="#DELETE-触发器" class="headerlink" title="DELETE 触发器"></a>DELETE 触发器</h4></blockquote><p><em>DELETE</em> 触发器在 DELETE 语句执行之前或者之后，需要知道以下两点：</p><ol><li>在 DELETE 触发器代码内，可以应用一个名为 OLD 的虚拟表，来访问被删除的行；</li><li>OLD 表中的数据只能读，不能被更新，而在 INSERT 触发器中，就可以通过 NEW 来更新被插入的行数据；</li></ol><p>例如,针对 customers 表，当删除一行数据时，返回被删除的 <code>cust_id</code> 以及 <code>cust_name</code>：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/*创建DELETE触发器*/</span><span class="token keyword">DELIMITER</span> <span class="token comment" spellcheck="true">//</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> insertcustomers <span class="token keyword">AFTER</span> <span class="token keyword">DELETE</span> <span class="token keyword">ON</span> customers<span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span><span class="token keyword">SELECT</span> OLD<span class="token punctuation">.</span>cust_name <span class="token keyword">INTO</span> <span class="token variable">@deletecustname</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> OLD<span class="token punctuation">.</span>cust_id <span class="token keyword">INTO</span> <span class="token variable">@deletecustid</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">/*调用DELETE触发器*/</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token variable">@deletecustname</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token variable">@deletecustid</span><span class="token punctuation">;</span></code></pre><p>基本上与创建 INSERT 触发器一样，只不过在 DELETE 触发器中只能使用 OLD 来访问被删除的行数据。</p></li></ol><blockquote><h4 id="UPDATE-触发器"><a href="#UPDATE-触发器" class="headerlink" title="UPDATE 触发器"></a>UPDATE 触发器</h4></blockquote><p>UPDATE 触发器在 UPDATE 语句执行前或者之后执行，需要知道几点：</p><ol><li>在 BEFORE UPDATE 触发器中可以使用 NEW 和 OLD 来访问数据，而在 AFTER UPDATE 触发器中使用 NEW 来访问数据会报错，只能使用 OLD 来访问数据；</li><li>在 BEFORE UPDATE 触发器中，NEW 中的值可以改变，即允许更改将用户 UPDATE 的数据；</li><li>OLD 中的行数据只能读，不能被更新；</li></ol><p>一个 UPDATE 触发器示例如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">/*创建触发器*/</span><span class="token keyword">DELIMITER</span> <span class="token comment" spellcheck="true">//</span><span class="token keyword">DELETE</span> <span class="token keyword">TRIGGER</span> insertcustomers BEFORE <span class="token keyword">UPDATE</span> <span class="token keyword">ON</span> customers<span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span><span class="token keyword">SELECT</span> NEW<span class="token punctuation">.</span>cust_name <span class="token keyword">INTO</span> <span class="token variable">@beforeupdate</span><span class="token punctuation">;</span><span class="token keyword">SET</span> NEW<span class="token punctuation">.</span>cust_name <span class="token operator">=</span> <span class="token string">'reset_name'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> OLD<span class="token punctuation">.</span>cust_name <span class="token keyword">INTO</span> <span class="token variable">@afterupdate</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">/*调用UPDATE触发器*/</span><span class="token keyword">UPDATE</span> customers <span class="token keyword">SET</span> cust_name <span class="token operator">=</span> <span class="token string">'happy'</span> <span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token variable">@beforeupdate</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token variable">@afterupdate</span><span class="token punctuation">;</span></code></pre><pre><code>输出为@beforeupdate 为 &#39;happy&#39;，而@afterupdate 为 &#39;reset_name&#39;。有这样一些细节：1.  NEW 虚拟表中的数据可以更改， 如这里采用    `SET NEW.cust_name = &#39;reset_name&#39;;`，将待更新的    `cust_name` 由 `happy` 变成了 `reset_name`；2.  在 BEFORE UPDATE 触发器中可以使用 NEW 和 OLD 来访问数据，而在 AFTER UPDATE 触发器冲使用 NEW 来访问数据会报错；</code></pre><p>3.如何删除触发器？</p><p>删除触发器，可以使用 <em>DROP TRIGGER</em> 语句，比如：<br><code>DROP TRIGGER insertcustomers;</code>。触发器不能更新或者覆盖，如果要修改触发器，必须删除这个触发器。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
